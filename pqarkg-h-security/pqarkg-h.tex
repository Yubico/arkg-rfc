\documentclass[a4paper,11pt]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[style=alphabetic]{biblatex}
\usepackage{hyperref}
\usepackage{url}
\usepackage[keys,lambda,sets,adversary,advantage,events,logic,operators,probability,ff,primitives]{cryptocode}
\usepackage{xspace}
\usepackage{draftwatermark}
\usepackage{amsthm}

\addbibresource{pqarkg-h.bib}

\author{Emil Lundberg\\Yubico AB\\emil@yubico.com}
\title{Quantum-safe Hierarchical Deterministic Keys with the pqARKG-H extension}

\SetWatermarkText{Draft}
\SetWatermarkScale{8}
\SetWatermarkColor[gray]{0.85}

\newcommand{\figlabel}[1]{\label{fig:{#1}}}
\newcommand{\figref}[1]{Figure~\ref{fig:{#1}}}

\newcommand{\ALGNAME}{pqARKG\babelhyphen{nobreak}H\xspace}
\newcommand{\ALGBASE}{pqARKG\xspace}
\newcommand{\pub}{\ensuremath{\mathsf{pp}}\xspace}
\newcommand{\bl}{\ensuremath{\mathsf{\Delta}}\xspace}
\let\oldsk\sk\renewcommand{\sk}{\oldsk\xspace}
\let\oldpk\pk\renewcommand{\pk}{\oldpk\xspace}
\newcommand{\kem}{\ensuremath{\mathsf{\Pi}}\xspace}
\newcommand{\aux}{\ensuremath{\mathsf{aux}}\xspace}
\newcommand{\cred}{\ensuremath{\mathsf{cred}}\xspace}
\newcommand{\msks}{\ensuremath{\mathsf{msKS}}\xspace}

\newcommand{\barvar}[1]{\ensuremath{\overline{#1}}}
\newcommand{\starvar}[1]{\ensuremath{{#1}^\star}\xspace}
\newcommand{\pkstar}{\starvar{\pk}}
\newcommand{\skstar}{\starvar{\sk}}
\newcommand{\bstar}{\starvar{b}}
\newcommand{\cstar}{\starvar{c}}
\newcommand{\credstar}{\starvar{\cred}}
\newcommand{\auxstar}{\starvar{\aux}}

\newcommand{\skbl}{\ensuremath{\sk_\bl}\xspace}
\newcommand{\skbd}{\ensuremath{\sk^{b}_{\bl}}\xspace}
\newcommand{\skbsd}{\ensuremath{\sk^{\bstar}_{\bl}}\xspace}
\newcommand{\skkem}{\ensuremath{\sk_\kem}\xspace}
\newcommand{\pkp}{\ensuremath{\pk'}\xspace}
\newcommand{\skp}{\ensuremath{\sk'}\xspace}
\newcommand{\pkbl}{\ensuremath{\pk_\bl}\xspace}
\newcommand{\pkbd}{\ensuremath{\pk^{b}_{\bl}}\xspace}
\newcommand{\pkbsd}{\ensuremath{\pk^{\bstar}_{\bl}}\xspace}
\newcommand{\pkkem}{\ensuremath{\pk_\kem}\xspace}

\newcommand{\algname}[1]{\ensuremath{\mathsf{#1}}\xspace}
\newcommand{\algsetup}{\algname{Setup}}
\newcommand{\algcheck}{\algname{Check}}
\newcommand{\algkgen}{\algname{KeyGen}}
\newcommand{\algdpk}{\algname{DerivePK}}
\newcommand{\algdsk}{\algname{DeriveSK}}

\newcommand{\algbl}[1]{\bl.{#1}}
\newcommand{\algblcheck}{\algbl{\algcheck}}
\newcommand{\algblkgen}{\algbl{\algkgen}}
\newcommand{\algblbpk}{\algbl{\algname{BlindPK}}}
\newcommand{\algblbsk}{\algbl{\algname{BlindSK}}}
\newcommand{\algblupk}{\algbl{\algname{UnblindPK}}}
\newcommand{\algblusk}{\algbl{\algname{UnblindSK}}}

\newcommand{\algkem}[1]{\kem.{#1}}
\newcommand{\algkemkgen}{\algkem{\algkgen}}
\newcommand{\algkemenc}{\algkem{\algname{Encaps}}}
\newcommand{\algkemdec}{\algkem{\algname{Decaps}}}

\newcommand{\defproc}[2]{\procedure[linenumbering,width=\linewidth]{\ensuremath{#1}}{#2}}
\newcommand{\experiment}[2]{\ensuremath{\mathsf{Exp}^{#1}_{#2}}\xspace}
\let\oldadv\adv\renewcommand{\adv}{\oldadv\xspace}
\let\oldbdv\bdv\renewcommand{\bdv}{\oldbdv\xspace}
\let\oldprf\prf\renewcommand{\prf}{\oldprf\xspace}
\newcommand{\Oracle}{\ensuremath{\mathcal{O}}}
\newcommand{\Opkp}{\ensuremath{\Oracle_{\pkp}}\xspace}
\newcommand{\Oskp}{\ensuremath{\Oracle_{\skp}}\xspace}
\newcommand{\pklist}{\ensuremath{\mathsf{PKList}}\xspace}
\newcommand{\sklist}{\ensuremath{\mathsf{SKList}}\xspace}
\newcommand{\expmsksbase}{\experiment{\msks}{\ALGBASE,\adv}}
\newcommand{\expmsksnew}{\experiment{\msks}{\ALGNAME,\bdv}}
\newcommand{\explain}[1]{\left\{\text{#1}\right\}}

\newcommand{\id}{\ensuremath{\mathsf{id_\Delta}}}

\let\oldconcat\concat\renewcommand{\concat}{\oldconcat\,}

\newtheorem{theorem}{Theorem}[section]

\begin{document}
\maketitle

\begin{abstract}
Hierarchical Deterministic Keys (HDK) is a draft specification
using key blinding techniques including ARKG
to create hierarchies of keys all derived from a single root secret key,
in such a way that only the root secret key needs to be kept in a secure element (SE)
and new public keys can be generated without invoking the SE.
However, when ARKG is used in HDK, the original ARKG procedures
would require one SE invocation per HDK layer when exercising derived private keys.
This is undesirable in contexts where each SE invocation would require a distinct user gesture.

To address this we analyze the security of an ARKG extension \ALGNAME
that enables any number of HDK layers with a single SE invocation.
We base \ALGNAME on the ARKG generalization \ALGBASE,
and demonstrate that it retains \msks security
by a straightforward reduction of the security experiment.
\end{abstract}


\section{Introduction}
Hierarchical Deterministic Keys (HDK) \cite{HDK} is a draft specification
using key blinding techniques including ARKG \cite{ARKG}
to create hierarchies of keys all derived from a single root secret key,
in such a way that only the root secret key needs to be kept in a secure element (SE)
and new public keys can be generated without invoking the SE.
However, when ARKG is used in HDK, the original ARKG procedures
would require one SE invocation of \algdsk per HDK layer when exercising derived private keys.
This is undesirable in contexts where each SE invocation would require a distinct user gesture.
One such context is the WebAuthn ``sign'' extension \cite{webauthn-sign}
proposed to introduce general-purpose signing capabilities to the Web Authentication API (WebAuthn) \cite{webauthn},
including signing using private keys derived via ARKG.
Since WebAuthn requires a user gesture for any signing operation,
HDK operations based on this ``sign'' extension would also require one user gesture per HDK layer.

The ARKG construction in \cite{ARKG} is based upon \ALGBASE \cite{Wilson},
a~post-quantum compatible generalization of the original ARKG \cite{Frymann2020}.
Here we propose and analyze \ALGNAME, an extension of pqARKG for better compatibility with HDK.
\ALGNAME enables any number of HDK layers with a single invocation of the \algdsk procedure.

The next section repeats the definition of \ALGBASE and its \msks security experiment.
Then we propose the extension \ALGNAME and its corresponding security experiment,
and finally demonstrate by a straightforward reduction
that \ALGNAME retains the \msks property of \ALGBASE.


\section{pqARKG}

Here we repeat the definition of \ALGBASE and its \msks security experiment \cite{Wilson}.
The instance parameters are a key blinding scheme \bl,
a~key encapsulation mechanism (KEM) \kem
and a pseudo-random function \prf outputting blinding factors in the domain of \bl.

\ALGBASE is defined as the suite of procedures in \figref{pqarkg}.
The \msks security experiment for \ALGBASE is defined in \figref{exp-msks-pqarkg}.
\footnote{We have corrected a misprint in \cite{Wilson} writing $\tau$ in place of $k$ on line 3 of \Oskp,
renamed the variable $\mathsf{ck}$ to $\tau$ in \Opkp,
and~made explicit the argument \pub to \algcheck.}

\begin{figure}
  \figlabel{pqarkg}
  \centering
  \begin{minipage}{0.6\linewidth}

    \defproc{\algsetup(\secpar)}{
      \pcreturn \pub=(\bl, \kem, \prf)
    }
    \bigskip

    \defproc{\algcheck(\pub, \skp, \pkp)}{
      \pcreturn \algblcheck(\skp, \pkp)
    }
    \bigskip

    \defproc{\algkgen(\pub)}{
      (\skbl, \pkbl) \leftarrow \algblkgen() \\
      (\skkem, \pkkem) \leftarrow \algkemkgen() \\
      \pcreturn \sk=(\skbl, \skkem), \pk=(\pkbl, \pkkem)
    }
    \bigskip

    \defproc{\algdpk(\pub, \pk = (\pkbl, \pkkem), \aux)}{
      (c, k) \leftarrow \algkemenc(\pkkem) \\
      \tau \leftarrow \prf(k, \aux) \\
      \pkp \leftarrow \algblbpk(\pkbl, \tau) \\
      \pcreturn \pkp, \cred = (c, \aux)
    }
    \bigskip

    \defproc{\algdsk(\pub, \sk =(\skbl, \skkem), \cred =(c, \aux))}{
      k \leftarrow \algkemdec(\skkem, c) \\
      \tau \leftarrow \prf(k, \aux) \\
      \pcreturn \algblbsk(\skbl, \tau)
    }

  \end{minipage}
  \caption{Algorithms of the \ALGBASE scheme \cite{Wilson}.}
\end{figure}


\begin{figure}
  \figlabel{exp-msks-pqarkg}
  \centering
  \begin{minipage}[t]{0.5\linewidth}
    \defproc{\expmsksbase(\secpar)}{
      \pub \leftarrow \algsetup(\secparam) \\
      \pklist \leftarrow \emptyset \\
      \sklist \leftarrow \emptyset \\
      (\sk, \pk) \sample \algkgen() \\
      (\skstar, \pkstar, \credstar) \sample \adv^{\Opkp, \Oskp}(\pub, \pk) \\
      \skp \leftarrow \algdsk(\pub, \sk, \credstar) \\
      \pcreturn \algcheck(\pub, \skstar, \pkstar) \\
      \hphantom{\pcreturn} \land \algcheck(\pub, \skp, \pkstar) \\
      \hphantom{\pcreturn} \land \left[ \credstar \not\in \sklist \right]
    }
    \bigskip
  \end{minipage}
  \hspace{0.05\linewidth}
  \begin{minipage}[t]{0.4\linewidth}
    \defproc{\Opkp(\aux)}{
      (c, k) \sample \algkemenc(\pkkem) \\
      \tau \leftarrow \prf(k, \aux) \\
      \pkp \leftarrow \algblbpk(\pkbl, \tau) \\
      \pklist \leftarrow \pklist \cup \left\{ \left(\pkp, \left(c, \aux\right)\right) \right\} \\
      \pcreturn \pkp, (c, \aux)
    }
    \bigskip

    \defproc{\Oskp(c, \aux)}{
      \pcif (\cdot, (c, \aux)) \not\in \pklist \pcthen \pcreturn \bot \\
      \sklist \leftarrow \sklist \cup \left\{ (c, \aux) \right\} \\
      k \leftarrow \algkemdec(\skkem, c) \\
      \tau \leftarrow \prf(k, \aux) \\
      \pcreturn \algblbsk(\skbl, \tau)
    }
  \end{minipage}
  \caption{The \msks security experiment for \ALGBASE~\cite{Wilson}.}
\end{figure}



\section{\ALGNAME}

Here we define our modified \ALGNAME scheme and a corresponding \msks security experiment.

A new parameter~$b$ is added to the \algdpk and \algdsk functions.
This~$b$ is an additional blinding factor in the key blinding scheme~\bl,
allowing the ARKG delegating party (the party holding the ARKG private seed) to add any number of additional blinding layers
on top of the one performed by the ARKG subordinate party (the party generating public keys).
To~prevent choosing $b = -\tau$ so that it cancels the blinding factor~$\tau$
computed in step~2 of~\algdsk of~\ALGBASE, this~$b$ is also mixed into the PRF arguments to compute~$\tau$.
This disrupts any algebraic relationship between $b$ and~$\tau$,
thus preventing extraction of the private seed~\sk by a malicious choice of~$b$
even if a derived private key \skp is leaked.

The new argument mixed into the PRF is however not $b$ directly,
but a blinded public key~\pkbd incorporating the blinding factor~$b$.
This enables the delegating party to share a derived public \ALGNAME seed with a subordinate party without having to disclose~$b$.
This is desirable if the delegating party does not wish to reveal
the relationship with other keys in an HDK tree which might be used for unrelated purposes;
knowing~$b$ would enable the subordinate party to unblind the derived public key~\pkp to reveal the root public seed~\pkbl.
Instead, the subordinate party may determine $k$ and~\aux and compute steps 3--5 of \algdpk with $\pkbl=\pkbd$ and~$b=\id$,
the identity blinding factor,
and thus be convinced that \pkp was generated from the claimed public seed~\pkbd.

Finally, the \algdsk function of~\ALGNAME also receives the blinding key \pkbl as a new parameter
in order to reconstruct the same PRF output as~\algdpk.
This~\pkbl parameter may be eliminated in instantiations where~\pkbl can be computed from~\skbl.

\ALGNAME requires three additional properties of the the key blinding scheme~\bl:

\begin{enumerate}
\item{There exists an \emph{identity blinding factor}, denoted \id,
  such that
  $$ \algblbpk(\pk, \id) = \pk \text{\xspace and \xspace} \algblbsk(\sk, \id) = \sk $$
  for all \pk and \sk.}

\item{\bl supports \emph{public key unblinding} in addition to private key unblinding:
  A function $\algblupk(\pk, b)$ such that
  $$ \algblupk(\algblbpk(\pk, b), b) = \pk $$
  for all \pk and $b$.}

\item{\bl is \emph{commutative} in the blinding factor:
  for all \pk, \sk, $a$ and $b$,
  $$ \algblbpk(\algblbpk(\pk, a), b) = \algblbpk(\algblbpk(\pk, b), a) $$
  $$\algblbsk(\algblbsk(\sk, a), b) = \algblbsk(\algblbsk(\sk, b), a). $$
}
\end{enumerate}

For example, any construction based on cyclic groups is likely to satisfy these properties.

\ALGNAME is defined as the suite of procedures in \figref{pqarkg}.
The operator~\concat denotes binary concatenation,
and we assume some well-known encoding is used for $\pkbd$.
Note that if $\algblbsk(\sk, b)$ is linear in $b$ with operation $\circ$,
then steps 4-5 of \algdsk may be optimized as "$4. \, \pcreturn \algblbsk(\skbl, b\ \circ \tau)$".

\begin{figure}
  \figlabel{pqarkg-h}
  \centering
  \begin{minipage}{0.7\linewidth}

    \algsetup: Same as \ALGBASE. \\
    \algcheck: Same as \ALGBASE. \\
    \algkgen: Same as \ALGBASE. \\

    \defproc{\algdpk(\pub, \pk = (\pkbl, \pkkem), b, \aux)}{
      (c, k) \leftarrow \algkemenc(\pkkem) \\
      \pkbd \leftarrow \algblbpk(\pkbl, b) \\
      \tau \leftarrow \prf(k, \pkbd \concat \aux) \\
      \pkp \leftarrow \algblbpk(\pkbd, \tau) \\
      \pcreturn \pkp, \cred = (c, \aux)
    }
    \bigskip

    \defproc{\algdsk(\pub, \pkbl, \sk=(\skbl, \skkem), b, \cred =(c, \aux))}{
      k \leftarrow \algkemdec(\skkem, c) \\
      \pkbd \leftarrow \algblbpk(\pkbl, b) \\
      \tau \leftarrow \prf(k, \pkbd \concat \aux) \\
      \skbd \leftarrow \algblbsk(\skbl, b) \\
      \pcreturn \algblbsk(\skbd, \tau)
    }

  \end{minipage}
  \caption{
    Algorithms of the \ALGNAME scheme.
    The \algsetup, \algcheck and \algkgen algorithms are unchanged from \ALGBASE.
  }
\end{figure}

We also modify the \msks security experiment accordingly,
resulting in the security experiment \expmsksnew.
The main difference is that the adversary \bdv also returns the value \bstar to be used as the $b$ argument to \algdsk.
The public and private key oracles \Opkp and \Oskp are also updated to include the $b$ parameter
and the additional blinding step.
Finally, the check against \bdv trivially querying \Oskp for a solution
is relaxed to forbid only the exact combination of \bstar and \credstar returned as the solution.

\begin{figure}
  \figlabel{exp-msks-pqarkg-h}
  \centering
  \begin{minipage}[t]{0.5\linewidth}
    \defproc{\expmsksnew(\secpar)}{
      \pub \leftarrow \algsetup(\secparam) \\
      \pklist \leftarrow \emptyset \\
      \sklist \leftarrow \emptyset \\
      (\sk, \pk) \sample \algkgen() \\
      (\skstar, \pkstar, \bstar, \credstar) \sample \bdv^{\Opkp, \Oskp}(\pub, \pk) \\
      \skp \leftarrow \algdsk(\pub, \pkbl, \sk, \bstar, \credstar) \\
      \pcreturn \algcheck(\pub, \skstar, \pkstar) \\
      \hphantom{\pcreturn} \land \algcheck(\pub, \skp, \pkstar) \\
      \hphantom{\pcreturn} \land \left[ (\bstar, \credstar) \not\in \sklist \right]
    }
    \bigskip
  \end{minipage}
  \hspace{0.05\linewidth}
  \begin{minipage}[t]{0.4\linewidth}
    \defproc{\Opkp(b, \aux)}{
      (\pkp, \cred) \sample \algdpk(\pub, \pk, b, \aux) \\
      \pklist \leftarrow \pklist \cup \left\{ \left(\pkp, \cred \right) \right\} \\
      \pcreturn (\pkp, \cred)
    }
    \bigskip

    \defproc{\Oskp(b, c, \aux)}{
      \pcif (\cdot, (c, \aux)) \not\in \pklist \pcthen \pcreturn \bot \\
      \sklist \leftarrow \sklist \cup \left\{ (b, (c, \aux)) \right\} \\
      \pcreturn \algdsk(\pub, \pkbl, \sk, b, (c, \aux))
    }
  \end{minipage}
  \caption{The \msks security experiment for \ALGNAME.}
\end{figure}


\section{Reduction of \ALGBASE to \ALGNAME in \msks security experiment}

We now show that \ALGNAME can satisfy malicious strong key security \msks. The proof requires two additional properties of some key blinding schemes that are defined in \cite{Wilson}: unique blinding and private-key unblinding. Recall from \cite{Wilson} that \ALGBASE satisfies \msks when instantiated with a key blinding scheme that provides these properties. Therefore a reduction proof from \ALGNAME to \ALGBASE suffices.

\begin{theorem}
Let \ALGNAME be the ARKG construction described in \figref{pqarkg-h}, instantiated with a key blinding scheme \bl that provides unique blinding and supports private-key unblinding. For any efficient adversary \bdv, there exists an efficient algorithm \adv such that
$$ \advantage{\msks}{\ALGNAME,\bdv} = \advantage{\msks}{\ALGBASE,\adv} $$
where the security experiment \msks is defined in \figref{exp-msks-pqarkg-h} for \ALGNAME and in \figref{exp-msks-pqarkg} for \ALGBASE.
\end{theorem}

\begin{proof}

Given an adversary \bdv that defeats \expmsksnew,
we construct an adversary \adv that defeats \expmsksbase.

\begin{figure}
  \figlabel{adv-reduction}
  \centering
  \begin{minipage}[t]{0.6\linewidth}
    \defproc{\adv^{\Opkp, \Oskp}(\pub = (\bl, \kem, \prf), \pk = (\pkbl, \pkkem))}{
      (\barvar{\skstar}, \barvar{\pkstar}, \barvar{\bstar}, (\barvar{\cstar}, \barvar{\auxstar})) \sample \bdv^{\barvar{\Opkp}, \barvar{\Oskp}}(\pub, \pk) \\
      \skstar \leftarrow \algblusk(\barvar{\skstar}, \barvar{\bstar}) \\
      \pkstar \leftarrow \algblupk(\barvar{\pkstar}, \barvar{\bstar}) \\
      \pkbsd \leftarrow \algblbpk(\pkbl, \barvar{\bstar}) \\
      \pcreturn (\skstar, \pkstar, (\barvar{\cstar}, \pkbsd \concat \barvar{\auxstar}))
    }
    \bigskip
  \end{minipage}
  \hspace{0.05\linewidth}
  \begin{minipage}[t]{0.3\linewidth}
    \defproc{\overline{\Opkp}(b, \aux)}{
      \pkbd \leftarrow \algblbpk(\pkbl, b) \\
      (\pkp, (c, \cdot)) \sample \Opkp(\pkbd \concat \aux) \\
      \barvar{\pkp} \leftarrow \algblbpk(\pkp, b) \\
      \pcreturn (\barvar{\pkp}, (c, \aux))
    }
    \bigskip

    \defproc{\barvar{\Oskp}(b, c, \aux)}{
      \pkbd \leftarrow \algblbpk(\pkbl, b) \\
      \skp \leftarrow \Oskp(c, \pkbd \concat \aux) \\
      \pcreturn \algblbsk(\skp, b)
    }
  \end{minipage}
  \caption{Reduction of \expmsksbase to \expmsksnew.}
\end{figure}

When invoked, this adversary \adv simply invokes the given adversary \bdv with its own challenge.
The \Opkp and~\Oskp oracles are adapted for~\bdv
by adding the \pkbd~prefix to~\aux and performing the additional blinding with the $b$ argument,
thus \adv faithfully simulates \expmsksnew for \bdv.
The \auxstar returned to the challenger is adapted with the \pkbsd prefix
computed using the blinding factor $\barvar{\bstar}=\bstar$ returned by~\bdv,
thus~\ALGNAME produces the same $\tau$ on line 3 of its \algdpk and \algdsk functions
as \ALGBASE does on line 2 of its \algdpk and \algdsk functions.

To prove that \adv wins its game precisely when \bdv wins its game, we observe that \adv passes each of the three conditions on lines 7--9 of \expmsksbase if and only if \bdv passes the corresponding condition from the ones on lines 7--9 of \expmsksnew.

For the first condition this holds because by definition of \skstar and \pkstar, and applying the unique blinding and private-key unblinding properties,

\begin{align*}
  \algblcheck(\pub, \skstar, \pkstar)
  &= \algblcheck(\pub, \algblusk(\barvar{\skstar}, \barvar{\bstar}), \algblupk(\barvar{\pkstar}, \barvar{\bstar})) \\
  &= \algblcheck(\pub, \barvar\skstar, \barvar\pkstar).
\end{align*}

For the second condition this holds because of the following argument.
First, observe that $\cstar = \barvar{\cstar}$ and $\auxstar = \pkbsd \concat \barvar{\auxstar}$,
and therefore
$$ \tau = \prf(\algkemdec(\skkem, \cstar), \auxstar) = \prf(\algkemdec(\skkem, \barvar{\cstar}), \pkbsd \concat \barvar{\auxstar}) $$
so \algdsk on line~6 of \expmsksbase computes the same $\tau$ as on line~6 of \expmsksnew.
The above gives
\begin{align*}
  \skp &= \algdsk(\pub, \sk, \credstar) \\
  &= \algblbsk(\skbl, \prf(\algkemdec(\skkem, \cstar), \auxstar)) \\
  &= \algblbsk(\skbl, \tau)
\end{align*}
where $\credstar = (\cstar, \auxstar)$.
Let \barvar{\skp} be an alias of the target symbol on line 6 of \expmsksnew.
Then
\begin{align*}
  \barvar{\skp} &= \algdsk(\pub, \pkbl, \sk, \barvar{\bstar}, \barvar{\credstar}) \\
  &= \algblbsk(\algblbsk(\skbl, \barvar{\bstar}), \tau) \\
  &= \algblbsk(\algblbsk(\skbl, \tau), \barvar{\bstar}) \\
  &= \algblbsk(\skp, \barvar{\bstar})
\end{align*}
and therefore
$$ \skp = \algblusk(\barvar{\skp}, \barvar{\bstar}) $$
so by the definitions of unblinding and unique blinding,
the second condition in \expmsksnew is equivalent to
\begin{align*}
  \algblcheck(\pub, \barvar\skp,\barvar\pkstar)
  &= \algblcheck(\pub, \barvar\skp, \algblbpk(\algblupk(\barvar{\pkstar}, \barvar{\bstar}), \barvar{\bstar})) \\
  &= \algblcheck(\pub, \barvar\skp, \algblbpk(\pkstar, \barvar{\bstar})) \\
  &= \algblcheck(\pub, \algblbsk(\skp, \barvar{\bstar}), \algblbpk(\pkstar, \barvar{\bstar})) \\
  &= \algblcheck(\pub, \skp, \pkstar).
\end{align*}

For the third condition this holds because \adv only appends to \sklist when invoking \Oskp, which it does only when \bdv invokes \barvar{\Oskp}.
Therefore if \bdv does not invoke \barvar{\Oskp} with arguments $(\bstar, \cstar, \auxstar)$,
then \adv also does not invoke \Oskp with arguments $(\cstar, \auxstar)$.
This is the case when \bdv wins its game, therefore \adv passes the condition  $(\cstar, \auxstar) \not\in \sklist$ whenever \bdv does.

\end{proof}


\section{Acknowledgements}

We would like to thank Sander Dijkhuis for proposing the construction with mixing \pkbd into the PRF instead of $b$,
and for helping find a successful approach for the security reduction.


\printbibliography


\end{document}
